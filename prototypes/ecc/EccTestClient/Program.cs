using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Opc.Ua;

namespace EccTestClient
{
    class Program
    {
        static void Main(string[] args)
        {
            EccOpenSsl.EccTester tester = new EccOpenSsl.EccTester();
            tester.Initialize();

            // certs are generated with openssl and use the NIST p256 curve.
            string senderCertificateFilePath = Path.Combine("..\\..\\..\\..\\pki\\certs\\", "Charlie.der");
            string senderKeyFilePath = Path.Combine("..\\..\\..\\..\\pki\\private\\", "Charlie.pem");

            string receiverCertificateFilePath = Path.Combine("..\\..\\..\\..\\pki\\certs\\", "Diana.der");
            string receiverKeyFilePath = Path.Combine("..\\..\\..\\..\\pki\\private\\", "Diana.pem");

            // set the certificate used by the openssl side.
            tester.SetLocalCertificate(receiverCertificateFilePath, receiverKeyFilePath, null);

            senderKeyFilePath = Path.Combine("..\\..\\..\\..\\pki\\private\\", "Charlie.pfx");
            X509Certificate2 sender = new X509Certificate2(senderKeyFilePath, "password", X509KeyStorageFlags.Exportable | X509KeyStorageFlags.UserKeySet);

            // create a 'open secure channel request' that includes an ephermal key generated in .NET.
            ECDiffieHellmanCng senderEmpheralKey;
            CreateOpenSecureChannelRequest(sender, "request.uabinary", out senderEmpheralKey);
            Debug.Assert(senderEmpheralKey != null);

            // validates the signature created in .NET and creates reply that includes an ephermal key generated by OpenSSL.
            // The shared key is created by OpenSSL (private) * .NET (public).
            var sharedKey1 = tester.Decode("request.uabinary", "response.uabinary");

            // validates the signature created in OpenSSL.
            // The shared key is created by .NET (private) * .OpenSSL (public).
            // sharedKey1 and sharedKey2 are supposed to be the same - they aren't.
            var sharedKey2 = ProcessOpenSecureChannelResponse(senderEmpheralKey, "response.uabinary");

            if (!AreEqual(sharedKey1, sharedKey2))
            {
                Console.WriteLine("KEYS DO NOT MATCH!");
            }

            // As a sanity check derive keys using only .NET APIs
            var sanityECDH = new ECDiffieHellmanCng(ECCurve.NamedCurves.nistP256);
            sanityECDH.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
            sanityECDH.HashAlgorithm = CngAlgorithm.Sha512;

            var export = senderEmpheralKey.Key.Export(CngKeyBlobFormat.EccPublicBlob);
            var import = ECDiffieHellmanCngPublicKey.FromByteArray(export, CngKeyBlobFormat.EccPublicBlob);
            var sharedKey3 = sanityECDH.DeriveKeyMaterial(import);

            export = sanityECDH.Key.Export(CngKeyBlobFormat.EccPublicBlob);
            import = ECDiffieHellmanCngPublicKey.FromByteArray(export, CngKeyBlobFormat.EccPublicBlob);
            var sharedKey4 = senderEmpheralKey.DeriveKeyMaterial(import);

            if (!AreEqual(sharedKey3, sharedKey4))
            {
                Console.WriteLine("SANITY CHECK KEYS DO NOT MATCH!");
            }

            tester.Cleanup();
        }

        static bool AreEqual(IList<byte> value1, IList<byte> value2)
        {
            if (value1 == null || value2 == null || value2.Count != value1.Count)
            {
                return false;
            }

            for (int ii = 0; ii < value1.Count; ii++)
            {
                if (value1[ii] != value2[ii])
                {
                    return false;
                }
            }

            return true;
        }

        static byte[] Encode(X509Certificate2 publicKey, ECDsaCng signingKey, ECDiffieHellmanCng ephemeralKey)
        {
            var data = ephemeralKey.Key.Export(CngKeyBlobFormat.EccPublicBlob);
            var signingCertificate = publicKey.RawData;

            var buffer = new byte[UInt16.MaxValue];

            int ephemeralKeySize = ephemeralKey.KeySize / 4;
            int length = 12 + ephemeralKeySize + signingCertificate.Length;

            int signatureLength = signingKey.KeySize / 4;
            length += signatureLength;

            using (var ostrm = new System.IO.MemoryStream(buffer, true))
            {
                ostrm.Write(BitConverter.GetBytes(length), 0, 4);
                ostrm.Write(BitConverter.GetBytes(signingCertificate.Length), 0, 4);
                ostrm.Write(signingCertificate, 0, signingCertificate.Length);
                ostrm.Write(BitConverter.GetBytes(ephemeralKeySize), 0, 4);
                ostrm.Write(data, 8, ephemeralKeySize);

                SHA256Cng sha = new SHA256Cng();
                var hash = sha.ComputeHash(buffer, 0, length - signatureLength);
                // Console.WriteLine("HASH {0}", FormatHexString(hash));

                var signature = signingKey.SignData(buffer, 0, length - signatureLength, HashAlgorithmName.SHA256);
                // Console.WriteLine("SIG {0}", FormatHexString(signature));
                ostrm.Write(signature, 0, signature.Length);
                ostrm.Close();

                using (ECDsa ecdsa = publicKey.GetECDsaPublicKey())
                {
                    if (!ecdsa.VerifyData(buffer, 0, length - signature.Length, signature, HashAlgorithmName.SHA256))
                    {
                        throw new Exception("Generated signature not valid.");
                    }
                }

                return ostrm.ToArray();
            }
        }

        static ECDiffieHellmanPublicKey Decode(byte[] data)
        {
            var length = BitConverter.ToInt32(data, 0);

            var signingCertificateLength = BitConverter.ToInt32(data, 4);
            var signingCertificate = new byte[signingCertificateLength];
            Buffer.BlockCopy(data, 8, signingCertificate, 0, signingCertificateLength);

            var publicKey = new X509Certificate2(signingCertificate);

            using (ECDsa ecdsa = publicKey.GetECDsaPublicKey())
            {
                var signature = new byte[ecdsa.KeySize / 4];
                Buffer.BlockCopy(data, length - signature.Length, signature, 0, signature.Length);

                SHA256Cng sha = new SHA256Cng();
                var hash = sha.ComputeHash(data, 0, length - signature.Length);
                // Console.WriteLine("HASH {0}", FormatHexString(hash));
                // Console.WriteLine("SIG {0}", FormatHexString(signature));

                if (!ecdsa.VerifyData(data, 0, length - signature.Length, signature, HashAlgorithmName.SHA256))
                {
                    throw new Exception("Received signature not valid.");
                }
            }

            int start = 8 + signingCertificateLength;
            var keyLength = BitConverter.ToInt32(data, start);
            start += 4;

            using (var ostrm = new System.IO.MemoryStream())
            {
                ostrm.WriteByte(0x45);
                ostrm.WriteByte(0x43);
                ostrm.WriteByte(0x4B);
                ostrm.WriteByte(0x31);
                ostrm.Write(BitConverter.GetBytes(keyLength / 2), 0, 4);
                ostrm.Write(data, start, keyLength);
                ostrm.Close();

                var ephemeralKey = ostrm.ToArray();
                return ECDiffieHellmanCngPublicKey.FromByteArray(ephemeralKey, CngKeyBlobFormat.EccPublicBlob);
            }
        }

        static byte[] Encode(ECDiffieHellmanCng ephemeralKey)
        {
            var data = ephemeralKey.Key.Export(CngKeyBlobFormat.EccPublicBlob);

            int ephemeralKeySize = ephemeralKey.KeySize / 4;
            int length = 4 + ephemeralKeySize;

            byte[] buffer = new byte[length];
            Buffer.BlockCopy(BitConverter.GetBytes(ephemeralKeySize), 0, buffer, 0, 4);
            Buffer.BlockCopy(data, 8, buffer, 0, ephemeralKeySize);
            return buffer;
        }

        static string FormatHexString(byte[] bytes)
        {
            System.Text.StringBuilder buffer = new StringBuilder();

            for (int ii = 0; ii < bytes.Length; ii++)
            {
                buffer.AppendFormat("{0:X2}", bytes[ii]);
            }

            return buffer.ToString();
        }

        static byte[] CreateOpenSecureChannelRequest(X509Certificate2 sender, string requestFilePath, out ECDiffieHellmanCng senderECDH)
        {
            X509Certificate2 senderPublicKey = new X509Certificate2(sender.RawData);
            var senderPrivateKey = sender.GetECDsaPrivateKey() as ECDsaCng;

            senderECDH = (ECDiffieHellmanCng)ECDiffieHellmanCng.Create(ECCurve.NamedCurves.nistP256);
            senderECDH.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
            senderECDH.HashAlgorithm = CngAlgorithm.Sha512;

            var request = Encode(senderPublicKey, senderPrivateKey, senderECDH);
            System.IO.File.WriteAllBytes(requestFilePath, request);
            return request;
        }

        static byte[] ProcessOpenSecureChannelRequest(X509Certificate2 receiver, string requestFilePath, string responseFilePath)
        {
            var request = System.IO.File.ReadAllBytes(requestFilePath);
            var senderKeyData = Decode(request);

            X509Certificate2 receiverPublicKey = new X509Certificate2(receiver.RawData);
            var receiverPrivateKey = receiver.GetECDsaPrivateKey() as ECDsaCng;

            ECDiffieHellmanCng receiverECDH = new ECDiffieHellmanCng(ECCurve.NamedCurves.nistP256);
            receiverECDH.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
            receiverECDH.HashAlgorithm = CngAlgorithm.Sha256;

            byte[] sharedKey = receiverECDH.DeriveKeyMaterial(senderKeyData);

            var response = Encode(receiverPublicKey, receiverPrivateKey, receiverECDH);
            System.IO.File.WriteAllBytes(responseFilePath, response);
            return response;
        }

        static  byte[]  ProcessOpenSecureChannelResponse(ECDiffieHellmanCng senderECDH, string responseFilePath)
        {
            var response = System.IO.File.ReadAllBytes(responseFilePath);
            var receiverKeyData = Decode(response);

            byte[] sharedKey = senderECDH.DeriveKeyMaterial(receiverKeyData);
            return sharedKey;
        }
    }
}
