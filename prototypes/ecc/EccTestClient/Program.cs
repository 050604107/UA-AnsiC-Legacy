using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Opc.Ua;

namespace EccTestClient
{
    class Program
    {
        static void Main(string[] args)
        {
            EccOpenSsl.EccTester tester = new EccOpenSsl.EccTester();
            tester.Initialize();

            // certs are generated with openssl and use the NIST p256 curve.
            string senderCertificateFilePath = Path.Combine("..\\..\\..\\..\\pki\\certs\\", "Charlie.der");
            string senderKeyFilePath = Path.Combine("..\\..\\..\\..\\pki\\private\\", "Charlie.pem");

            string receiverCertificateFilePath = Path.Combine("..\\..\\..\\..\\pki\\certs\\", "Diana.der");
            string receiverKeyFilePath = Path.Combine("..\\..\\..\\..\\pki\\private\\", "Diana.pem");

            // set the certificate used by the openssl side.
            tester.SetLocalCertificate(receiverCertificateFilePath, receiverKeyFilePath, null);

            senderKeyFilePath = Path.Combine("..\\..\\..\\..\\pki\\private\\", "Charlie.pfx");
            X509Certificate2 sender = new X509Certificate2(senderKeyFilePath, "password", X509KeyStorageFlags.Exportable | X509KeyStorageFlags.UserKeySet);

            // create a 'open secure channel request' that includes an ephermal key generated in .NET.
            ECDiffieHellmanCng senderEmpheralKey;
            byte[] clientNonce = null;
            CreateOpenSecureChannelRequest(sender, "request.uabinary", out senderEmpheralKey, out clientNonce);
            Debug.Assert(senderEmpheralKey != null);

            // validates the signature created in .NET and creates reply that includes an ephermal key generated by OpenSSL.
            // The shared key is created by OpenSSL (private) * .NET (public).
            var sharedKey1 = tester.Decode("request.uabinary", "response.uabinary");

            // validates the signature created in OpenSSL.
            // The shared key is created by .NET (private) * .OpenSSL (public).
            // sharedKey1 and sharedKey2 are supposed to be the same - they aren't.
            byte[] serverNonce = null;
            var sharedKey2 = ProcessOpenSecureChannelResponse(senderEmpheralKey, "response.uabinary", out serverNonce);

            if (!AreEqual(sharedKey1, sharedKey2))
            {
                Console.WriteLine("KEYS DO NOT MATCH!");
            }

            var serverKeys = DeriveKeys(sharedKey1, serverNonce, 80);
            Console.WriteLine("NET: ServerSigningKey: {0}", FormatHexString(serverKeys, 0, 32));
            Console.WriteLine("NET: ServerEncryptingKey: {0}", FormatHexString(serverKeys, 32, 32));
            Console.WriteLine("NET: ServerInitializationVector: {0}", FormatHexString(serverKeys, 64, 16));

            var clientKeys = DeriveKeys(sharedKey1, clientNonce, 80);
            Console.WriteLine("NET: ClientSigningKey: {0}", FormatHexString(clientKeys, 0, 32));
            Console.WriteLine("NET: ClientEncryptingKey: {0}", FormatHexString(clientKeys, 32, 32));
            Console.WriteLine("NET: ClientInitializationVector: {0}", FormatHexString(clientKeys, 64, 16));

            tester.Cleanup();
            Console.ReadLine();
        }

        static byte[] DeriveKeys(byte[] secret, byte[] seed, int length)
        {
            //Console.WriteLine("NET: Secret: {0}", FormatHexString(secret));
            //Console.WriteLine("NET: Seed: {0}", FormatHexString(seed));

            HMACSHA256 hmac = new HMACSHA256(secret);

            byte[] keySeed = hmac.ComputeHash(seed);
            //Console.WriteLine("NET: A(1): {0}", FormatHexString(keySeed));

            byte[] prfSeed = new byte[hmac.HashSize/8 + seed.Length];
            Buffer.BlockCopy(keySeed, 0, prfSeed, 0, keySeed.Length);
            Buffer.BlockCopy(seed, 0, prfSeed, keySeed.Length, seed.Length);
            //Console.WriteLine("NET: S(1): {0}", FormatHexString(prfSeed));

            // create buffer with requested size.
            byte[] output = new byte[length];

            int position = 0;

            do
            {
                byte[] hash = hmac.ComputeHash(prfSeed);
                //Console.WriteLine("NET: R(1): {0}", FormatHexString(hash));

                for (int ii = 0; position < length && ii < hash.Length; ii++)
                {
                    output[position++] = hash[ii];
                }

                keySeed = hmac.ComputeHash(keySeed);
                Buffer.BlockCopy(keySeed, 0, prfSeed, 0, keySeed.Length);
            }
            while (position < length);

            return output;
        }

        static bool AreEqual(IList<byte> value1, IList<byte> value2)
        {
            if (value1 == null || value2 == null || value2.Count != value1.Count)
            {
                return false;
            }

            for (int ii = 0; ii < value1.Count; ii++)
            {
                if (value1[ii] != value2[ii])
                {
                    return false;
                }
            }

            return true;
        }

        static byte[] Encode(X509Certificate2 publicKey, ECDsaCng signingKey, ECDiffieHellmanCng ephemeralKey, byte[] senderNonce)
        {
            var data = ephemeralKey.Key.Export(CngKeyBlobFormat.EccPublicBlob);
            var signingCertificate = publicKey.RawData;

            var buffer = new byte[UInt16.MaxValue];

            int ephemeralKeySize = ephemeralKey.KeySize / 4;

            int length = 16 + ephemeralKeySize + signingCertificate.Length + senderNonce.Length;

            int signatureLength = signingKey.KeySize / 4;
            length += signatureLength;

            using (var ostrm = new System.IO.MemoryStream(buffer, true))
            {
                ostrm.Write(BitConverter.GetBytes(length), 0, 4);
                ostrm.Write(BitConverter.GetBytes(signingCertificate.Length), 0, 4);
                ostrm.Write(signingCertificate, 0, signingCertificate.Length);
                ostrm.Write(BitConverter.GetBytes(ephemeralKeySize), 0, 4);
                ostrm.Write(data, 8, ephemeralKeySize);
                ostrm.Write(BitConverter.GetBytes(senderNonce.Length), 0, 4);
                ostrm.Write(senderNonce, 0, senderNonce.Length);

                SHA256Cng sha = new SHA256Cng();
                var hash = sha.ComputeHash(buffer, 0, length - signatureLength);
                // Console.WriteLine("HASH {0}", FormatHexString(hash));

                var signature = signingKey.SignData(buffer, 0, length - signatureLength, HashAlgorithmName.SHA256);
                // Console.WriteLine("SIG {0}", FormatHexString(signature));
                ostrm.Write(signature, 0, signature.Length);
                ostrm.Close();

                using (ECDsa ecdsa = publicKey.GetECDsaPublicKey())
                {
                    if (!ecdsa.VerifyData(buffer, 0, length - signature.Length, signature, HashAlgorithmName.SHA256))
                    {
                        throw new Exception("Generated signature not valid.");
                    }
                }

                return ostrm.ToArray();
            }
        }

        static ECDiffieHellmanPublicKey Decode(byte[] data, out byte[] senderNonce)
        {
            var length = BitConverter.ToInt32(data, 0);

            var signingCertificateLength = BitConverter.ToInt32(data, 4);
            var signingCertificate = new byte[signingCertificateLength];
            Buffer.BlockCopy(data, 8, signingCertificate, 0, signingCertificateLength);

            var publicKey = new X509Certificate2(signingCertificate);

            using (ECDsa ecdsa = publicKey.GetECDsaPublicKey())
            {
                var signature = new byte[ecdsa.KeySize / 4];
                Buffer.BlockCopy(data, length - signature.Length, signature, 0, signature.Length);

                SHA256Cng sha = new SHA256Cng();
                var hash = sha.ComputeHash(data, 0, length - signature.Length);
                // Console.WriteLine("HASH {0}", FormatHexString(hash));
                // Console.WriteLine("SIG {0}", FormatHexString(signature));

                if (!ecdsa.VerifyData(data, 0, length - signature.Length, signature, HashAlgorithmName.SHA256))
                {
                    throw new Exception("Received signature not valid.");
                }
            }

            int start = 8 + signingCertificateLength;
            var keyLength = BitConverter.ToInt32(data, start);
            start += 4;

            int nonceLength = BitConverter.ToInt32(data, start + keyLength);
            senderNonce = new byte[nonceLength];
            Array.Copy(data, start + keyLength + 4, senderNonce, 0, senderNonce.Length);

            using (var ostrm = new System.IO.MemoryStream())
            {
                ostrm.WriteByte(0x45);
                ostrm.WriteByte(0x43);
                ostrm.WriteByte(0x4B);
                ostrm.WriteByte(0x31);
                ostrm.Write(BitConverter.GetBytes(keyLength / 2), 0, 4);
                ostrm.Write(data, start, keyLength);
                ostrm.Close();

                var ephemeralKey = ostrm.ToArray();
                return ECDiffieHellmanCngPublicKey.FromByteArray(ephemeralKey, CngKeyBlobFormat.EccPublicBlob);
            }
        }

        static byte[] Encode(ECDiffieHellmanCng ephemeralKey)
        {
            var data = ephemeralKey.Key.Export(CngKeyBlobFormat.EccPublicBlob);

            int ephemeralKeySize = ephemeralKey.KeySize / 4;
            int length = 4 + ephemeralKeySize;

            byte[] buffer = new byte[length];
            Buffer.BlockCopy(BitConverter.GetBytes(ephemeralKeySize), 0, buffer, 0, 4);
            Buffer.BlockCopy(data, 8, buffer, 0, ephemeralKeySize);
            return buffer;
        }
        
        static string FormatHexString(byte[] bytes, int offset = 0, int length = -1)
        {
            if (length < 0)
            {
                length = bytes.Length;
            }

            System.Text.StringBuilder buffer = new StringBuilder();

            for (int ii = offset; ii < offset + length; ii++)
            {
                buffer.AppendFormat("{0:X2}", bytes[ii]);
            }

            return buffer.ToString();
        }

        static byte[] CreateOpenSecureChannelRequest(X509Certificate2 sender, string requestFilePath, out ECDiffieHellmanCng senderECDH, out byte[] senderNonce)
        {
            X509Certificate2 senderPublicKey = new X509Certificate2(sender.RawData);
            var senderPrivateKey = sender.GetECDsaPrivateKey() as ECDsaCng;

            senderECDH = (ECDiffieHellmanCng)ECDiffieHellmanCng.Create(ECCurve.NamedCurves.nistP256);
            senderECDH.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
            senderECDH.HashAlgorithm = CngAlgorithm.Sha256;

            senderNonce = new byte[senderECDH.KeySize / 8];
            new RNGCryptoServiceProvider().GetBytes(senderNonce);

            var request = Encode(senderPublicKey, senderPrivateKey, senderECDH, senderNonce);
            System.IO.File.WriteAllBytes(requestFilePath, request);
            return request;
        }

        static byte[] ProcessOpenSecureChannelRequest(X509Certificate2 receiver, string requestFilePath, string responseFilePath, out byte[] receiverNonce)
        {
            var request = System.IO.File.ReadAllBytes(requestFilePath);

            byte[] senderNonce = null;
            var senderKeyData = Decode(request, out senderNonce);

            X509Certificate2 receiverPublicKey = new X509Certificate2(receiver.RawData);
            var receiverPrivateKey = receiver.GetECDsaPrivateKey() as ECDsaCng;

            ECDiffieHellmanCng receiverECDH = new ECDiffieHellmanCng(ECCurve.NamedCurves.nistP256);
            receiverECDH.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;
            receiverECDH.HashAlgorithm = CngAlgorithm.Sha256;

            byte[] sharedKey = receiverECDH.DeriveKeyMaterial(senderKeyData);

            receiverNonce = new byte[receiverECDH.KeySize / 2];
            new RNGCryptoServiceProvider().GetBytes(receiverNonce);

            var response = Encode(receiverPublicKey, receiverPrivateKey, receiverECDH, receiverNonce);
            System.IO.File.WriteAllBytes(responseFilePath, response);
            return response;
        }

        static  byte[]  ProcessOpenSecureChannelResponse(ECDiffieHellmanCng senderECDH, string responseFilePath, out byte[] serverNonce)
        {
            var response = System.IO.File.ReadAllBytes(responseFilePath);

            var receiverKeyData = Decode(response, out serverNonce);

            byte[] sharedKey = senderECDH.DeriveKeyMaterial(receiverKeyData);
            return sharedKey;
        }
    }
}
